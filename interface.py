# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'interface.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import math
import re
import sys
import PyQt5
import cv2
import numpy
import numpy as np
import PySide2.QtCore as QtCore
import PySide2.QtGui as QtGui
import PySide2.QtWidgets as QtWidgets
from PIL import ImageQt
from PyQt5.QtWidgets import *
import cv2
from PyQt5 import Qt
import os
import main
import PIL.Image as Image
# from Extract import img_extract


class Ui_Form(object):

    def cv_imread(self,filePath):
        # 核心就是下面这句，一般直接用这句就行，直接把图片转为mat数据
        cv_img = cv2.imdecode(np.fromfile(filePath, dtype=np.uint8), -1)
        # imdecode读取的是rgb，如果后续需要opencv处理的话，需要转换成bgr，转换后图片颜色会变化
        # cv_img=cv2.cvtColor(cv_img,cv2.COLOR_RGB2BGR)
        return cv_img
    def m4_CoordinateConvert(self, x0, y0, x1, y1, win_width, win_heigh, image_width, image_heigh):
        '''
        :param x0: 矩形框的左上点x坐标(窗口上的）
        :param y0: 矩形框的左上点y坐标(窗口上的）
        :param x1: 矩形框的右下点x坐标(窗口上的）
        :param y1: 矩形框的右下点y坐标(窗口上的）
        :param win_width: 显示窗口的长度
        :param win_heigh: 显示窗口的宽度
        :param image_width: 图像的宽度
        :param image_heigh: 图像的宽度
        :return: 图像上对应的坐标
        '''
        m4_ratioX = image_width / win_width
        m4_ratioY = image_heigh / win_heigh

        x_tl = x0 * m4_ratioX
        y_tl = y0 * m4_ratioY
        x_br = x1 * m4_ratioX
        y_br = y1 * m4_ratioY
        m4_Coordinate = (int(x_tl), int(y_tl), int(x_br), int(y_br))
        return m4_Coordinate

    def get_Label_pos(self):
        x0 = self.label_2.geometry().x()
        y0 = self.label_2.geometry().y()
        x1 = x0+self.label_2.width()
        y1 = y0+self.label_2.height()
        return (x0,y0,x1,y1)

    def setupUi(self, Form):

        class Editable_Label(QtWidgets.QLabel, QtWidgets.QWidget):
            global frame_paintCopy
            global frame_paint
            global RawImgSelected
            global RawImgPathExist

            def mousePressEvent(self, ev: QtGui.QMouseEvent) -> None:
                global W, frame_paintCopy
                global H
                global mouseEventType
                # global frame_paintCopy
                # global frame_paint
                global frameImgSavePath
                if(mouseEventType == 1):
                    lis_pos.clear()
                    global Img_paintCopy
                    global Img_paint
                    Img_paintCopy = Ui_Form.cv_imread(self,Img_paint)
                    Img_paintCopy = Img_paintCopy.copy()
                    if paint_flag:
                        W = LABEL_2.width()
                        H = LABEL_2.height()
                        LABEL_2.clear()
                        LABEL_2.setPixmap(
                            QtGui.QPixmap(Img_paint).scaled(W, H,
                                                            aspectMode=QtCore.Qt.KeepAspectRatio))
                        x = ev.localPos().x()
                        y = ev.localPos().y()
                        #记录
                        global rawImgPath
                        lis_pos.append(x)
                        lis_pos.append(y)
                        if (len(lis_pos) == 4):
                            Img_raw = Ui_Form.cv_imread(self,Img_paint)
                            Img_raw = Img_raw.copy()
                            Img_QImage = QtGui.QImage(Img_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio)
                            Img_Image = Image.fromarray(Img_paintCopy)
                            #计算label坐标在图片中对应的坐标
                            x0 = lis_pos[0]/Img_QImage.width()*Img_Image.width
                            x1 = lis_pos[2]/Img_QImage.width()*Img_Image.width
                            y0 = (lis_pos[1]-(H/2-Img_QImage.height()/2))/Img_QImage.height()*Img_Image.height
                            y1 = (lis_pos[3]-(H/2-Img_QImage.height()/2))/Img_QImage.height()*Img_Image.height
                            cv2.line(Img_paintCopy, (int(x0),int(y0)), (int(x1),int(y1)), (0,255,0), 2)
                            RGBImg = cv2.cvtColor(Img_paintCopy, cv2.COLOR_BGR2RGB)
                            # 将图片转化成Qt可读格式
                            image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0], RGBImg.shape[1]*3,QtGui.QImage.Format_RGB888)
                            LABEL_2.setPixmap(QtGui.QPixmap(QtGui.QImage(image)).scaled(W,H,
                                                                                   aspectMode=QtCore.Qt.KeepAspectRatio))
                            if_ok = QMessageBox.question(None,"比例尺","是否使用当前线条")
                            if if_ok==65536:
                                Img_paintCopy = Img_raw
                                lis_pos.clear()
                                LABEL_2.clear()
                                LABEL_2.setPixmap(
                                    QtGui.QPixmap(Img_paint).scaled(W, H,
                                                                    aspectMode=QtCore.Qt.KeepAspectRatio))
                                return
                            else:
                                # print(x1,x0,y1,y0)
                                s = (((x1-x0)**2+(y1-y0)**2)**0.5)*scale
                                QtWidgets.QMessageBox.information(None,"真实距离","所标记的真实距离为:"+str(round(s,3)))
                                with open(rawImgPath+"\\records.txt",'a') as file:
                                    file.write(Img_paint + " " + "比例尺：1:"+str(round(scale,8))+" 标记坐标：(" + str(round(x0,2)) + "," + str(round(y0,2)) + ")和("+str(round(x1,2))+","+str(round(y1,2))+ ') ')
                                    file.write("实际尺寸：" + str(round(s,3)))
                                    file.write("\n")
                                lis_pos.clear()
                if(mouseEventType == 2):
                    frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                    frame_paintCopy = frame_paintCopy.copy()
                    if paint_flag:
                        W = LABEL.width()
                        H = LABEL.height()
                        LABEL.setPixmap(QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                        x = ev.localPos().x()
                        y = ev.localPos().y()
                        global frameImgSavePath
                        lis_pos.append(x)
                        lis_pos.append(y)
                        if(len(lis_pos) == 4):
                            frameImg_raw = Ui_Form.cv_imread(self, frame_paint)
                            frameImg_raw = frameImg_raw.copy()
                            Img_QImage = QtGui.QImage(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio)
                            Img_Image = Image.fromarray(frame_paintCopy)
                            # 计算label坐标在图片中对应的坐标
                            x0 = lis_pos[0] / Img_QImage.width() * Img_Image.width
                            x1 = lis_pos[2] / Img_QImage.width() * Img_Image.width
                            y0 = (lis_pos[1] - (
                                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                            y1 = (lis_pos[3] - (
                                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                            if(abs(x1 - x0) > abs(y1 - y0)):
                                cv2.line(frame_paintCopy, (int((x0 + x1) / 2), 0), (int((x1 + x0) / 2), H), (0, 255, 0), 2)
                            else:
                                cv2.line(frame_paintCopy, (0, int((y0 + y1) / 2)), (W * 2, int((y1 + y0) / 2)), (0, 255, 0), 2)
                            RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                            # 将图片转化成Qt可读格式
                            image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0],RGBImg.shape[1]*3, QtGui.QImage.Format_RGB888)
                            LABEL.setPixmap(QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H,aspectMode=QtCore.Qt.KeepAspectRatio))
                            if_ok = QMessageBox.question(None, "中位线", "是否确定当前中位线")
                            if if_ok == 65536:
                                frame_paintCopy = frameImg_raw
                                lis_pos.clear()
                                LABEL.clear()
                                LABEL.setPixmap(
                                    QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                                frame_paintCopy = None
                                return
                            else:
                                if (abs(x1 - x0) > abs(y1 - y0)):
                                    QtWidgets.QMessageBox.information(None, "中位线", "中位线为:" + "x = " + str((x1 + x0) // 2))
                                    with open(frameImgSavePath + "\\MedLineRecords.txt", 'a') as file:
                                        file.write(frame_paint + " 中位线：" + "x = " + str((x1 + x0) // 2))
                                        file.write("\n")
                                else:
                                    QtWidgets.QMessageBox.information(None, "中位线",
                                                                      "中位线为:" + "y = " + str((y1 + y0) // 2))
                                    with open(frameImgSavePath + "\\MedLineRecords.txt", 'a') as file:
                                        file.write(frame_paint + " 中位线：" + "y = " + str((y1 + y0) // 2))
                                        file.write("\n")
                                lis_pos.clear()
                                frame_paintCopy = None
                if (mouseEventType == 3):
                    frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                    frame_paintCopy = frame_paintCopy.copy()
                    if paint_flag:
                        W = LABEL.width()
                        H = LABEL.height()
                        LABEL.setPixmap(QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                        x = ev.localPos().x()
                        y = ev.localPos().y()
                        lis_pos.append(x)
                        lis_pos.append(y)
                        if (len(lis_pos) == 2):
                            frameImg_raw = Ui_Form.cv_imread(self, frame_paint)
                            frameImg_raw = frameImg_raw.copy()
                            Img_QImage = QtGui.QImage(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio)
                            Img_Image = Image.fromarray(frame_paintCopy)
                            # 计算label坐标在图片中对应的坐标
                            x0 = lis_pos[0] / Img_QImage.width() * Img_Image.width
                            y0 = (lis_pos[1] - (
                                    H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                            cv2.line(frame_paintCopy, (int(x0), 0), (int(x0), H), (0, 255, 0),2)
                            cv2.line(frame_paintCopy, (0, int(y0)), (2 * W, int(y0)), (0, 255, 0), 2)
                            RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                            # 将图片转化成Qt可读格式
                            image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0],RGBImg.shape[1]*3, QtGui.QImage.Format_RGB888)
                            LABEL.setPixmap(
                                QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                            if_ok = QMessageBox.question(None, "参考线", "是否确定当前垂直/水平参考线")
                            if if_ok == 65536:
                                frame_paintCopy = frameImg_raw
                                lis_pos.clear()
                                LABEL.clear()
                                LABEL.setPixmap(
                                    QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                                frame_paintCopy = None
                                return
                            else:
                                QtWidgets.QMessageBox.information(None, "参考线", "垂直参考线为:" + "x = " + str(int(x0)) + " 水平参考线为:" + str(int(y0)))
                                with open(frameImgSavePath + "\\GuidesRecords.txt", 'a') as file:
                                    file.write(frame_paint + "垂直参考线:x = " + str(int(x0)) + " 水平参考线:y = " + str(int(y0)))
                                    file.write("\n")
                                lis_pos.clear()
                                frame_paintCopy = None
                if (mouseEventType == 4):
                    if paint_flag:
                        W = LABEL.width()
                        H = LABEL.height()
                        x = ev.localPos().x()
                        y = ev.localPos().y()
                        lis_pos.append(x)
                        lis_pos.append(y)
                        if (len(lis_pos) == 2):
                            frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                            frame_paintCopy = frame_paintCopy.copy()
                        if(len(lis_pos) >= 4):
                            Img_QImage = QtGui.QImage(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio)
                            Img_Image = Image.fromarray(frame_paintCopy)
                            # 计算label坐标在图片中对应的坐标
                            x0 = lis_pos[len(lis_pos) - 2] / Img_QImage.width() * Img_Image.width
                            y0 = (lis_pos[len(lis_pos) - 1] - (
                                    H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                            x1 = lis_pos[len(lis_pos) - 4] / Img_QImage.width() * Img_Image.width
                            y1 = (lis_pos[len(lis_pos) - 3] - (
                                    H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                            cv2.line(frame_paintCopy, (int(x0), int(y0)), (int(x1), int(y1)), (0, 255, 0),2)
                            RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                            # 将图片转化成Qt可读格式
                            image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0],RGBImg.shape[1]*3, QtGui.QImage.Format_RGB888)
                            LABEL.setPixmap(
                                QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))

                if mouseEventType == 5:
                    global Turn
                    global centerX
                    global centerY
                    global edgeX1
                    global edgeY1
                    global edgeX2
                    global edgeY2
                    if(Turn != 3 or Turn == 3 and len(lis_pos) == 0):
                        frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                        frame_paintCopy = frame_paintCopy.copy()
                    if paint_flag:
                        W = LABEL.width()
                        H = LABEL.height()
                        if(Turn != 3 or Turn == 3 and len(lis_pos) == 0):
                            LABEL.setPixmap(
                                QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                        x = ev.localPos().x()
                        y = ev.localPos().y()
                        lis_pos.append(x)
                        lis_pos.append(y)
                        if (len(lis_pos) == 2 and Turn == 3):
                            QtWidgets.QMessageBox.information(None, '提示', '请补全框选区域!')
                        if Turn == 3:
                            frameImg_raw = Ui_Form.cv_imread(self, frame_paint)
                            frameImg_raw = frameImg_raw.copy()
                            Img_QImage = QtGui.QImage(frame_paint).scaled(W, H,
                                                                          aspectMode=QtCore.Qt.KeepAspectRatio)
                            Img_Image = Image.fromarray(frame_paintCopy)
                            if(len(lis_pos) == 4):
                                centerX = lis_pos[0] / Img_QImage.width() * Img_Image.width
                                centerY = (lis_pos[1] - (
                                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                                edgeX1 = lis_pos[2] / Img_QImage.width() * Img_Image.width
                                edgeY1 = (lis_pos[3] - (
                                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                                cv2.line(frame_paintCopy, (int(centerX), int(centerY)), (int(edgeX1), int(edgeY1)), (0, 255, 0), 2)
                                RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                                # 将图片转化成Qt可读格式
                                image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0], RGBImg.shape[1] * 3,
                                                     QtGui.QImage.Format_RGB888)
                                LABEL.setPixmap(
                                    QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H,
                                                                              aspectMode=QtCore.Qt.KeepAspectRatio))
                            elif(len(lis_pos) == 6):
                                edgeX2 = lis_pos[4] / Img_QImage.width() * Img_Image.width
                                edgeY2 = (lis_pos[5] - (
                                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                                cv2.line(frame_paintCopy, (int(centerX), int(centerY)), (int(edgeX1), int(edgeY1)),(0, 255, 0), 2)
                                cv2.line(frame_paintCopy, (int(centerX), int(centerY)), (int(edgeX2), int(edgeY2)),(0, 255, 0), 2)
                                cv2.line(frame_paintCopy, (int(edgeX1), int(edgeY1)), (int(edgeX2), int(edgeY2)),(0, 255, 0), 2)
                                RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                                # 将图片转化成Qt可读格式
                                image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0], RGBImg.shape[1] * 3,
                                                     QtGui.QImage.Format_RGB888)
                                LABEL.setPixmap(
                                    QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H,
                                                                              aspectMode=QtCore.Qt.KeepAspectRatio))
                                if_ok = QMessageBox.question(None, "待复制扇形", "是否确定当前旋转复制区域")
                                if if_ok == 65536:
                                    frame_paintCopy = frameImg_raw
                                    lis_pos.clear()
                                    LABEL.clear()
                                    LABEL.setPixmap(
                                        QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                                    return
                                else:
                                    frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                                    frame_paintCopy = frame_paintCopy.copy()
                                    img_rotate = self.imrotate(np.float32(np.array(frame_paintCopy)),[edgeX1,edgeY1],[edgeX2,edgeY2],[centerX,centerY])
                                    RGBImg = cv2.cvtColor(img_rotate, cv2.COLOR_BGR2RGB)
                                    # 将图片转化成Qt可读格式
                                    image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0], RGBImg.shape[1] * 3,
                                                         QtGui.QImage.Format_RGB888)
                                    LABEL_2.setPixmap(
                                        QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H,
                                                                                  aspectMode=QtCore.Qt.KeepAspectRatio))
                                    frame_paintCopy = None
                                    lis_pos.clear()


                        elif Turn == 1 or Turn == 2:
                            if (len(lis_pos) == 2):
                                frameImg_raw = Ui_Form.cv_imread(self, frame_paint)
                                frameImg_raw = frameImg_raw.copy()
                                Img_QImage = QtGui.QImage(frame_paint).scaled(W, H,
                                                                              aspectMode=QtCore.Qt.KeepAspectRatio)
                                Img_Image = Image.fromarray(frame_paintCopy)
                                # 计算label坐标在图片中对应的坐标
                                self.x0 = lis_pos[0] / Img_QImage.width() * Img_Image.width
                                self.y0 = (lis_pos[1] - (
                                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                                if Turn == 1:
                                    cv2.line(frame_paintCopy, (int(self.x0), 0), (int(self.x0), H), (0, 255, 0), 2)
                                elif Turn == 2:
                                    cv2.line(frame_paintCopy, (0, int(self.y0)), (2 * W, int(self.y0)), (0, 255, 0), 2)
                                RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                                # 将图片转化成Qt可读格式
                                image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0],RGBImg.shape[1]*3,
                                                     QtGui.QImage.Format_RGB888)
                                LABEL.setPixmap(
                                    QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H,
                                                                              aspectMode=QtCore.Qt.KeepAspectRatio))
                                if_ok = QMessageBox.question(None, "对称轴", "是否确定当前对称轴")
                                if if_ok == 65536:
                                    frame_paintCopy = frameImg_raw
                                    lis_pos.clear()
                                    LABEL.clear()
                                    LABEL.setPixmap(
                                        QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                                    frame_paintCopy = None
                                    return
                                else:
                                    lis_pos.clear()
                                    self.Turn = 0
                                    # 子窗口
                                    self.selectWidget = QWidget()
                                    # 设置窗口标题
                                    self.selectWidget.setWindowTitle("选择复制对象")
                                    # 设置窗口大小
                                    self.selectWidget.resize(400, 300)
                                    self.choose = 0
                                    if Turn == 1:
                                        # 复制左侧
                                        self.left_copy = QRadioButton(self.selectWidget)
                                        self.left_copy.setText('复制左侧')
                                        self.left_copy.move(150, 50)
                                        self.left_copy.toggled.connect(self.leftCopyFun)

                                        # 复制右侧
                                        self.right_copy = QRadioButton(self.selectWidget)
                                        self.right_copy.setText('复制右侧')
                                        self.right_copy.move(150, 100)
                                        self.right_copy.toggled.connect(self.rightCopyFun)

                                        # 确认按钮
                                        self.pushEnter1 = QPushButton(self.selectWidget)
                                        self.pushEnter1.setText("确认")
                                        self.pushEnter1.move(75, 200)
                                        self.pushEnter1.clicked.connect(self.pushEnter1Fun)

                                        # 退出按钮
                                        self.pushOut = QPushButton(self.selectWidget)
                                        self.pushOut.setText("取消")
                                        self.pushOut.move(200, 200)
                                        self.pushOut.clicked.connect(self.pushOutFun)
                                        self.selectWidget.show()
                                    elif Turn == 2:
                                        # 复制上侧
                                        self.up_copy = QRadioButton(self.selectWidget)
                                        self.up_copy.setText('复制上侧')
                                        self.up_copy.move(150, 50)
                                        self.up_copy.toggled.connect(self.leftCopyFun)

                                        # 复制下侧
                                        self.down_copy = QRadioButton(self.selectWidget)
                                        self.down_copy.setText('复制下侧')
                                        self.down_copy.move(150, 100)
                                        self.down_copy.toggled.connect(self.rightCopyFun)

                                        # 确认按钮
                                        self.pushEnter2 = QPushButton(self.selectWidget)
                                        self.pushEnter2.setText("确认")
                                        self.pushEnter2.move(75, 200)
                                        self.pushEnter2.clicked.connect(self.pushEnter2Fun)

                                        # 退出按钮
                                        self.pushOut = QPushButton(self.selectWidget)
                                        self.pushOut.setText("取消")
                                        self.pushOut.move(200, 200)
                                        self.pushOut.clicked.connect(self.pushOutFun)
                                        self.selectWidget.show()

            def imrotate(self,image, point1, point2, center):
                n = np.size(image, 0)
                m = np.size(image, 1)
                img = np.ones((n, m, 3))
                img.fill(255)
                point1 = list(point1)
                point2 = list(point2)
                center = list(center)
                point1[0], point1[1] = point1[1], point1[0]
                point2[0], point2[1] = point2[1], point2[0]
                center[0], center[1] = center[1], center[0]

                def is_in_poly(p, poly):
                    """
                    :param p: [x, y]
                    :param poly: [[], [], [], [], ...]
                    :return:
                    """
                    px, py = p
                    is_in = False
                    for i, corner in enumerate(poly):
                        next_i = i + 1 if i + 1 < len(poly) else 0
                        x1, y1 = corner
                        x2, y2 = poly[next_i]
                        if (x1 == px and y1 == py) or (
                                x2 == px and y2 == py):  # if point is on vertex
                            is_in = True
                            break
                        if min(y1, y2) < py <= max(y1, y2):  # find horizontal edges of polygon
                            x = x1 + (py - y1) * (x2 - x1) / (y2 - y1)
                            if x == px:  # if point is on edge
                                is_in = True
                                break
                            elif x > px:  # if point is on left-side of line
                                is_in = not is_in
                    return is_in

                def cal_ang(point_1, point_2, point_3):
                    """
                    根据三点坐标计算夹角
                    :param point_1: 点1坐标
                    :param point_2: 点2坐标
                    :param point_3: 点3坐标
                    :return: 返回任意角的夹角值，这里返回点2的夹角
                    """
                    a = math.sqrt((point_2[0] - point_3[0]) * (point_2[0] - point_3[0]) + (
                            point_2[1] - point_3[1]) * (
                                          point_2[1] - point_3[1]))
                    b = math.sqrt((point_1[0] - point_3[0]) * (point_1[0] - point_3[0]) + (
                            point_1[1] - point_3[1]) * (
                                          point_1[1] - point_3[1]))
                    c = math.sqrt((point_1[0] - point_2[0]) * (point_1[0] - point_2[0]) + (
                            point_1[1] - point_2[1]) * (
                                          point_1[1] - point_2[1]))
                    A = math.degrees(math.acos((a * a - b * b - c * c) / (-2 * b * c)))
                    B = math.degrees(math.acos((b * b - a * a - c * c) / (-2 * a * c)))
                    C = math.degrees(math.acos((c * c - a * a - b * b) / (-2 * a * b)))
                    return B

                b = cal_ang(point1, center, point2)
                b = -math.radians(b % 360)  # 将角度化为弧度
                b = abs(b)

                def inmap(x, y):
                    return True if x >= 0 and x < n and y >= 0 and y < m else False

                # 反向推
                for x in range(n):
                    for y in range(m):
                        count_degree = 0
                        while count_degree < 6.29:
                            x0 = (x - center[0]) * math.cos(-count_degree) + (
                                    y - center[1]) * math.sin(-count_degree) + center[0]
                            y0 = -1 * (x - center[0]) * math.sin(-count_degree) + (
                                    y - center[1]) * math.cos(-count_degree) + center[1]
                            count_degree += b
                            if not is_in_poly([x0, y0], [point1, point2, center]):
                                continue
                            # if count_degree!=0 and is_in_poly([x, y], [point1,point2,center]) and is_in_poly([x0, y0], [point1,point2,center]):
                            #     continue
                            # 双线性内插值
                            i = int(x0)
                            j = int(y0)
                            u = x0 - i
                            v = y0 - j
                            if inmap(i, j):
                                f1 = (1 - u) * (1 - v) * image[i, j]
                                img[x, y] = f1
                                if inmap(i, j + 1):
                                    f2 = (1 - u) * v * image[i, j + 1]
                                    img[x, y] += f2
                                if inmap(i + 1, j):
                                    f3 = u * (1 - v) * image[i + 1, j]
                                    img[x, y] += f3
                                if inmap(i + 1, j + 1):
                                    f4 = u * v * image[i + 1, j + 1]
                                    img[x, y] += f4
                            break
                # img1 = Image.fromarray(np.uint8(img))
                return np.uint8(img)


            def leftCopyFun(self):
                self.choose = 1

            def rightCopyFun(self):
                self.choose = 2

            def pushEnter1Fun(self):
                self.selectWidget.close()
                if self.choose == 0:
                    QtWidgets.QMessageBox.information(None, '提示', '未选中复制对象!')
                else:
                    global frame_paint
                    frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                    frame_paintCopy = frame_paintCopy.copy()
                    Img_Image = Image.fromarray(frame_paintCopy)
                    self.copywidth = int(Img_Image.width)
                    self.copyheight = int(Img_Image.height)
                    self.x0 = int(self.x0)
                    self.yo = int(self.y0)
                    if self.choose == 1:
                        self.leftImg = Img_Image.crop((0, 0, self.x0, self.copyheight))
                        self.resultImg = Image.new("RGB", (self.x0 * 2, self.copyheight))
                        self.horImg = self.leftImg.transpose(Image.FLIP_LEFT_RIGHT)
                        self.resultImg.paste(self.leftImg, (0, 0, self.x0, self.copyheight))
                        self.resultImg.paste(self.horImg, (self.x0, 0, 2 * self.x0, self.copyheight))
                    else:
                        self.rightImg = Img_Image.crop((self.x0, 0, self.copywidth, self.copyheight))
                        self.resultImg = Image.new("RGB", ((self.copywidth - self.x0) * 2, self.copyheight))
                        self.horImg = self.rightImg.transpose(Image.FLIP_LEFT_RIGHT)
                        self.resultImg.paste(self.horImg, (0, 0, self.copywidth - self.x0, self.copyheight))
                        self.resultImg.paste(self.rightImg, (
                        self.copywidth - self.x0, 0, 2 * (self.copywidth - self.x0), self.copyheight))
                    showimg = cv2.cvtColor(numpy.asarray(self.resultImg), cv2.COLOR_RGB2BGR)
                    cv2.imwrite("3.png", showimg)
                    showimg = cv2.cvtColor(showimg, cv2.COLOR_BGR2RGB)
                    # 将图片转化成Qt可读格式
                    image = QtGui.QImage(showimg, showimg.shape[1], showimg.shape[0], showimg.shape[1] * 3,
                                         QtGui.QImage.Format_RGB888)
                    LABEL_2.setPixmap(QtGui.QPixmap(QtGui.QImage(image)).scaled(LABEL_2.width(), LABEL_2.height(),
                                                                                aspectMode=QtCore.Qt.KeepAspectRatio))
                    if_ok = QMessageBox.question(None, "复制结果", "是否使用当前结果")
                    if if_ok == 65536:
                        lis_pos.clear()
                        LABEL_2.clear()
                        frame_paintCopy = None
                        if RawImgPathExist:
                            LABEL_2.setPixmap(
                                QtGui.QPixmap(RawImgSelected).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                        return
                    else:
                        lis_pos.clear()
                        frame_paintCopy = None
                        with open(frameImgSavePath + "\\horizontalCopyRecords.txt", 'a') as file:
                            if self.choose == 1:
                                file.write(frame_paint + " left " + str(self.x0))
                            else:
                                file.write(frame_paint + " right " + str(self.x0))
                            file.write("\n")

            def pushEnter2Fun(self):
                self.selectWidget.close()
                if self.choose == 0:
                    QtWidgets.QMessageBox.information(None, '提示', '未选中复制对象!')
                else:
                    global frame_paint
                    frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
                    frame_paintCopy = frame_paintCopy.copy()
                    Img_Image = Image.fromarray(frame_paintCopy)
                    self.copywidth = int(Img_Image.width)
                    self.copyheight = int(Img_Image.height)
                    self.x0 = int(self.x0)
                    self.y0 = int(self.y0)
                    if self.choose == 1:  # 复制上侧
                        self.upImg = Img_Image.crop((0, 0, self.copywidth, self.y0))
                        self.resultImg = Image.new("RGB", (self.copywidth, self.y0 * 2))
                        self.verImg = self.upImg.transpose(Image.FLIP_TOP_BOTTOM)
                        self.resultImg.paste(self.upImg, (0, 0, self.copywidth, self.y0))
                        self.resultImg.paste(self.verImg, (0, self.y0, self.copywidth, 2 * self.y0))
                    else:
                        self.downImg = Img_Image.crop((0, self.y0, self.copywidth, self.copyheight))
                        self.resultImg = Image.new("RGB", (self.copywidth, (self.copyheight - self.y0) * 2))
                        self.verImg = self.downImg.transpose(Image.FLIP_TOP_BOTTOM)
                        self.resultImg.paste(self.verImg, (0, 0, self.copywidth, self.copyheight - self.y0))
                        self.resultImg.paste(self.downImg, (
                        0, self.copyheight - self.y0, self.copywidth, 2 * (self.copyheight - self.y0)))
                    showimg = cv2.cvtColor(numpy.asarray(self.resultImg), cv2.COLOR_RGB2BGR)
                    showimg = cv2.cvtColor(showimg, cv2.COLOR_BGR2RGB)
                    # 将图片转化成Qt可读格式
                    image = QtGui.QImage(showimg, showimg.shape[1], showimg.shape[0], showimg.shape[1] * 3,
                                         QtGui.QImage.Format_RGB888)
                    LABEL_2.setPixmap(QtGui.QPixmap(QtGui.QImage(image)).scaled(LABEL_2.width(), LABEL_2.height(),
                                                                                aspectMode=QtCore.Qt.KeepAspectRatio))
                    if_ok = QMessageBox.question(None, "复制结果", "是否使用当前结果")
                    global frameImg_raw
                    if if_ok == 65536:
                        lis_pos.clear()
                        LABEL_2.clear()
                        if RawImgPathExist:
                            LABEL_2.setPixmap(
                                QtGui.QPixmap(RawImgSelected).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
                        return
                    else:
                        lis_pos.clear()
                        with open(frameImgSavePath + "\\verticalCopyRecords.txt", 'a') as file:
                            if self.choose == 1:
                                file.write(frame_paint + " up " + str(self.y0))
                            else:
                                file.write(frame_paint + " down " + str(self.y0))
                            file.write("\n")

            def pushOutFun(self):
                self.selectWidget.close()





        # self.getDoubleButton = QtWidgets.QPushButton(Form)
        # self.getDoubleButton.setGeometry(QtCore.QRect(50, 30, 80, 31))
        # self.getDoubleButton.setObjectName("getIntButton")

        Form.setObjectName("Form")
        Form.setFocusPolicy(QtCore.Qt.WheelFocus)
        #设置初始窗口大小
        Form.resize(1480,1210)

        #原始图片路径按钮
        global lis_pos,paint_flag,W,H
        paint_flag = False

        #比例尺
        global scale

        lis_pos = []
        self.pushButton = QtWidgets.QPushButton(Form)
        self.pushButton.setObjectName("选择原始图片")
        self.pushButton.setStyleSheet("background-color:rgb(111,180,219)")
        self.pushButton.setStyleSheet(
            "QPushButton{background-color:rgb(111,180,219)}"  # 按键背景色
            "QPushButton:hover{color:green}"  # 光标移动到上面后的前景色
            "QPushButton{border-radius:35px}"  # 圆角半径
            "QPushButton:pressed{background-color:rgb(180,180,180);border: None;}"  # 按下时的样式
        )
        self.rawImgPath = None #原始图保存路径
        global rawImgPath
        rawImgPath = None


        #框线图保存路径按钮
        self.pushButton_2 = QtWidgets.QPushButton(Form)
        self.pushButton_2.setObjectName("框线图保存路径")
        self.pushButton_2.setStyleSheet("background-color:rgb(111,180,219)")
        self.pushButton_2.setStyleSheet(
            "QPushButton{background-color:rgb(111,180,219)}"  # 按键背景色
            "QPushButton:hover{color:green}"  # 光标移动到上面后的前景色
            "QPushButton{border-radius:40px}"  # 圆角半径
            "QPushButton:pressed{background-color:rgb(180,180,180);border: None;}"  # 按下时的样式
        )
        self.frameImgSavePath = None
        self.FrameSaveDir=[]

        global frameImgSavePath
        frameImgSavePath = ""


        #AI图片保存路径
        self.pushButton_3 = QtWidgets.QPushButton(Form)
        self.pushButton_3.setObjectName("ai文件保存路径")
        self.pushButton_3.setStyleSheet("background-color:rgb(111,180,219)")
        self.pushButton_3.setStyleSheet(
            "QPushButton{background-color:rgb(111,180,219)}"  # 按键背景色
            "QPushButton:hover{color:green}"  # 光标移动到上面后的前景色
            "QPushButton{border-radius:40px}"  # 圆角半径
            "QPushButton:pressed{background-color:rgb(180,180,180);border: None;}"  # 按下时的样式
        )
        self.aiImgSavePath = None

        self.command = ""

        self.AIExePath = None

        global Img_paint
        Img_paint  = ""
        global Img_paintCopy
        Img_paintCopy = None

        #当前选中的框线图路径名
        global frame_paint
        frame_paint = ""
        global frame_paintCopy
        frame_paintCopy = None


        self.NewClassLabel = 0

        # AI软件保存路径
        self.pushButton_8 = QtWidgets.QPushButton(Form)
        self.pushButton_8.setObjectName("请选择AI软件")
        self.pushButton_8.setStyleSheet("background-color:rgb(111,180,219)")
        self.pushButton_8.setStyleSheet(
            "QPushButton{background-color:rgb(111,180,219)}"  # 按键背景色
            "QPushButton:hover{color:green}"  # 光标移动到上面后的前景色
            "QPushButton{border-radius:40px}"  # 圆角半径
            "QPushButton:pressed{background-color:rgb(180,180,180);border: None;}"  # 按下时的样式
        )

        #原始图片文件夹路径
        self.lineEdit = QtWidgets.QLineEdit(Form)
        self.lineEdit.setObjectName("lineEdit")

        # AI软件路径
        self.lineEdit_4 = QtWidgets.QLineEdit(Form)
        self.lineEdit_4.setObjectName("lineEdit_4")


        #保存框线图文件夹路径
        self.lineEdit_2 = QtWidgets.QLineEdit(Form)
        self.lineEdit_2.setObjectName("lineEdit_2")

        # AI图文件夹保存路径
        self.lineEdit_3 = QtWidgets.QLineEdit(Form)
        self.lineEdit_3.setObjectName("lineEdit_3")

##############################################################################

        #显示原始图
        self.label_2 = Editable_Label(Form)
        self.label_2.setFrameShape(QtWidgets.QFrame.Box)
        self.label_2.setText("")
        self.label_2.setObjectName("label_2")
        self.WIDTH = self.label_2.width()
        self.HEIGHT = self.label_2.height()

        global WIDTH,HEIGHT
        WIDTH = self.WIDTH
        HEIGHT = self.HEIGHT

        global LABEL_2
        LABEL_2 = self.label_2

        global centerX
        global centerY
        global edgeX1
        global edgeY1
        global edgeX2
        global edgeY2


        #显示框线图
        self.label = Editable_Label(Form)
        self.label.setFrameShape(QtWidgets.QFrame.Box)
        self.label.setText("")
        self.label.setObjectName("label")
        self.WIDTH2 = self.label.width()
        self.HEIGHT2 = self.label.height()

        global LABEL
        LABEL = self.label
###############################################################
        global mouseEventType

        #当前选中的原始图片路径名
        global RawImgSelected

        #判断原始图片路径是否打开
        global RawImgPathExist
        RawImgPathExist=False

        #绘制器物中位线
        self.pushButton_10 = QtWidgets.QPushButton(Form)
        self.pushButton_10.setObjectName("pushButton_10")

        #获取横向和纵向参考线
        self.pushButton_11 = QtWidgets.QPushButton(Form)
        self.pushButton_11.setObjectName("pushButton_11")

        #图像翻转复制
        self.pushButton_12 = QtWidgets.QPushButton(Form)
        self.pushButton_12.setObjectName("pushButton_12")

        #钢笔工具
        self.pushButton_13 = QtWidgets.QPushButton(Form)
        self.pushButton_13.setObjectName("pushButton_13")

        #钢笔撤销
        self.pushButton_14 = QtWidgets.QPushButton(Form)
        self.pushButton_14.setObjectName("pushButton_14")

        # 钢笔收笔
        self.pushButton_15 = QtWidgets.QPushButton(Form)
        self.pushButton_15.setObjectName("pushButton_15")
#######################################################################


        #提取框线图（单张）按钮
        self.pushButton_4 = QtWidgets.QPushButton(Form)
        self.pushButton_4.setObjectName("pushButton_4")

        #提取框线图（批量）按钮
        self.pushButton_5 = QtWidgets.QPushButton(Form)
        self.pushButton_5.setObjectName("pushButton_5")

        #下一张按钮
        self.pushButton_6 = QtWidgets.QPushButton(Form)
        self.pushButton_6.setObjectName("pushButton_6")
        self.rawImgIndex = 0

        #绘制按钮
        self.pushButton_9 = QtWidgets.QPushButton(Form)
        self.pushButton_9.setObjectName("pushButton_9")
        self.rawImgIndex = 0

        #框线图转ai 按钮
        self.pushButton_7 = QtWidgets.QPushButton(Form)

        #原始图片列表 标签
        self.label_3 = QtWidgets.QLabel(Form)
        self.label_3.setFrameShape(QtWidgets.QFrame.Box)
        self.label_3.setObjectName("label_3")
        self.label_3.setMaximumWidth(500)
        self.label_3.setMaximumHeight(500)

        #存放路径的原始图片列表 列表
        self.listWidget = QtWidgets.QListWidget(Form)
        self.listWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.listWidget.setObjectName("listWidget")
        self.rawImgSelected = [] #存放选中原始图选项的列表
        self.entireRawImg = [] #存放全体原始图
        self.listWidget.setMaximumWidth(500)
        self.listWidget.setMaximumHeight(500)


        #框线图列表 标签
        self.label_4 = QtWidgets.QLabel(Form)
        self.label_4.setFrameShape(QtWidgets.QFrame.Box)
        self.label_4.setObjectName("label_4")
        self.label_4.setMaximumWidth(500)
        self.label_4.setMaximumHeight(500)

        #存放框线图路径的列表 列表
        self.listWidget_2 = QtWidgets.QListWidget(Form)
        self.listWidget_2.setObjectName("listWidget_2")
        self.listWidget_2.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.listWidget_2.setMaximumWidth(500)
        self.listWidget_2.setMaximumHeight(500)


        #ai文件列表 标签
        self.label_5 = QtWidgets.QLabel(Form)
        self.label_5.setFrameShape(QtWidgets.QFrame.Box)
        self.label_5.setObjectName("label_5")
        self.label_5.setMaximumWidth(500)
        self.label_5.setMaximumHeight(500)

        #存放ai图片文件的列表 列表
        self.listWidget_3 = QtWidgets.QListWidget(Form)
        self.listWidget_3.setObjectName("listWidget_3")
        self.listWidget_3.setMaximumWidth(500)
        self.listWidget_3.setMaximumHeight(500)

        #界面布局
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(Form)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.horizontalLayout.addWidget(self.pushButton)
        self.horizontalLayout.addWidget(self.lineEdit)
        self.horizontalLayout.addWidget(self.pushButton_2)
        self.horizontalLayout.addWidget(self.lineEdit_2)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.verticalLayout_2.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.horizontalLayout_3.addWidget(self.pushButton_4)
        self.horizontalLayout_3.addWidget(self.pushButton_5)
        self.horizontalLayout_3.addWidget(self.pushButton_6)
        self.horizontalLayout_3.addWidget(self.pushButton_9)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.horizontalLayout_6.addWidget(self.pushButton_10)
        self.horizontalLayout_6.addWidget(self.pushButton_11)
        self.horizontalLayout_6.addWidget(self.pushButton_12)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.addWidget(self.pushButton_13)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.addWidget(self.pushButton_14)
        self.horizontalLayout_8.addWidget(self.pushButton_15)
        self.horizontalLayout_7.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_6.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_2.addLayout(self.horizontalLayout)
        self.verticalLayout_2.addLayout(self.horizontalLayout_3)
        self.verticalLayout_2.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.horizontalLayout_4.addWidget(self.pushButton_3)
        self.horizontalLayout_4.addWidget(self.lineEdit_3)
        self.horizontalLayout_4.addWidget(self.pushButton_8)
        self.horizontalLayout_4.addWidget(self.lineEdit_4)
        self.pushButton_7.setObjectName("pushButton_7")
        self.horizontalLayout_4.addWidget(self.pushButton_7)
        self.verticalLayout_2.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_5.addLayout(self.verticalLayout_2)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout.addWidget(self.label_3)
        self.verticalLayout.addWidget(self.listWidget)
        self.verticalLayout.addWidget(self.label_4)
        self.verticalLayout.addWidget(self.listWidget_2)
        self.verticalLayout.addWidget(self.label_5)
        self.verticalLayout.addWidget(self.listWidget_3)
        self.horizontalLayout_5.addLayout(self.verticalLayout)

        #绘制窗口
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

        #按钮回调
        self.pushButton.clicked.connect(self.pushButtonFun)
        self.listWidget.itemClicked.connect(self.listWidgets1_ItemClick)
        self.listWidget_2.itemClicked.connect(self.listWidgets2_ItemClick)
        self.pushButton_2.clicked.connect(self.pushButton_2Fun)
        self.pushButton_3.clicked.connect(self.pushButton_3Fun)
        self.pushButton_6.clicked.connect(self.pushButton_6Fun)
        self.pushButton_9.clicked.connect(self.pushButton_9Fun)
        self.pushButton_10.clicked.connect(self.pushButton_10Fun)
        self.pushButton_11.clicked.connect(self.pushButton_11Fun)
        self.pushButton_12.clicked.connect(self.pushButton_12Fun)
        self.pushButton_13.clicked.connect(self.pushButton_13Fun)
        self.pushButton_14.clicked.connect(self.pushButton_14Fun)
        self.pushButton_15.clicked.connect(self.pushButton_15Fun)
        # self.label_2.sender.connect(self.GetFeaturePoint)  # 自定义信号槽连接
        self.pushButton_4.clicked.connect(self.extractSelectedImage)
        self.pushButton_5.clicked.connect(self.extractAllImage)
        self.pushButton_8.clicked.connect(self.pushButton_8Fun)
        self.pushButton_7.clicked.connect(self.ChangeAI)


    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "框线图绘制&转AI"))
        self.pushButton.setText(_translate("Form", "选择原始图片"))
        self.pushButton_2.setText(_translate("Form", "框线图保存路径"))
        self.pushButton_4.setText(_translate("Form", "提取选中图片的框线图"))
        self.pushButton_5.setText(_translate("Form", "提取所有框线图"))
        self.pushButton_6.setText(_translate("Form", "下一张"))
        self.pushButton_9.setText(_translate("Form", "绘制比例尺"))
        self.pushButton_3.setText(_translate("Form", "ai文件保存路径"))
        self.pushButton_7.setText(_translate("Form", "框线图转ai"))
        self.label_3.setText(_translate("Form", "  原始图片列表"))
        self.label_4.setText(_translate("Form", "  框线图列表"))
        self.label_5.setText(_translate("Form", "   ai文件列表"))
        self.pushButton_8.setText(_translate("Form","请选择AI软件"))
        self.pushButton_10.setText(_translate("Form", "绘制器物中位线"))
        self.pushButton_11.setText(_translate("Form", "获取横向和纵向参考线"))
        self.pushButton_12.setText(_translate("Form", "图像翻转复制"))
        self.pushButton_13.setText(_translate("Form", "钢笔绘制"))
        self.pushButton_14.setText(_translate("Form", "撤销"))
        self.pushButton_15.setText(_translate("Form", "收笔"))
        self.horizontalLayout_2.addWidget(self.label)

    #回调函数
    def pushButtonFun(self):
        global Img_paint
        self.WIDTH = self.label_2.width()
        self.HEIGHT = self.label_2.height()
        self.listWidget.clear()
        self.entireRawImg.clear()
        self.rawImgPath = QtWidgets.QFileDialog.getExistingDirectory(None, "选取文件夹", "C:/")
        self.lineEdit.setText(self.rawImgPath)
        if self.rawImgPath=="":
            return
        global rawImgPath
        global RawImgPathExist
        RawImgPathExist=True
        rawImgPath = self.rawImgPath
        rawImg_list = os.listdir(self.rawImgPath)
        Img_paint = self.rawImgPath + '/' + rawImg_list[0]
        self.rawImgSelected.append(Img_paint)
        self.label_2.setPixmap(QtGui.QPixmap(self.rawImgPath + '/' + rawImg_list[0]).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
        for rawImg in rawImg_list:
            if(rawImg.endswith(".jpg") or rawImg.endswith(".png")): #支持jpg和png格式图片
                self.listWidget.addItem(self.rawImgPath + '/' + rawImg)
                self.entireRawImg.append(self.rawImgPath + '/' + rawImg)

    #点击图片路径的反应
    def listWidgets1_ItemClick(self):
        global RawImgSelected
        self.rawImgSelected.clear()
        items = self.listWidget.selectedItems()
        global Img_paint
        for item in items:
            item_name = item.text()
            Img_paint = item_name
            self.rawImgIndex = self.entireRawImg.index(item_name)
            self.rawImgSelected.append(item_name)
            self.label_2.setPixmap(QtGui.QPixmap(item_name).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            if(self.frameImgSavePath != None):
                if(self.frameImgSavePath + "/" + item_name.split("/")[-1][:-4]+".png" in self.FrameSaveDir):
                    frame_name = self.frameImgSavePath + "/" + item_name.split("/")[-1][:-4]+".png"
                    self.label.setPixmap(QtGui.QPixmap(frame_name).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
                else:
                    self.label.clear()
            else:
                self.label.clear()
        RawImgSelected = self.entireRawImg[self.rawImgIndex]

    def listWidgets2_ItemClick(self):
        global RawImgSelected
        global frame_paint
        global RawImgPathExist
        self.WIDTH = self.label.width()
        self.HEIGHT = self.label.height()
        item_name = self.listWidget_2.selectedItems()[0].text()
        frame_paint = item_name
        self.label.setPixmap(QtGui.QPixmap(item_name).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
        if RawImgPathExist==False :
            return
        if (self.rawImgPath + '/' + item_name.split("/")[-1][:-4] + ".png" in self.entireRawImg):
            self.label_2.setPixmap(
                QtGui.QPixmap(self.rawImgPath + '/' + item_name.split("/")[-1][:-4] + ".png").scaled(self.WIDTH,
                                                                                                     self.HEIGHT,aspectMode=QtCore.Qt.KeepAspectRatio))
            self.rawImgIndex = self.entireRawImg.index(self.rawImgPath + '/' + item_name.split("/")[-1][:-4] + ".png")
            RawImgSelected = self.entireRawImg[self.rawImgIndex]
        elif (self.rawImgPath + '/' + item_name.split("/")[-1][:-4] + ".jpg" in self.entireRawImg):
            self.label_2.setPixmap(
                QtGui.QPixmap(self.rawImgPath + '/' + item_name.split("/")[-1][:-4] + ".jpg").scaled(self.WIDTH,
                                                                                                     self.HEIGHT,aspectMode=QtCore.Qt.KeepAspectRatio))
            self.rawImgIndex = self.entireRawImg.index(self.rawImgPath + '/' + item_name.split("/")[-1][:-4] + ".jpg")
            RawImgSelected = self.entireRawImg[self.rawImgIndex]
        else:
            self.label_2.clear()


    #选择框线图保存路径
    def pushButton_2Fun(self):
        global frameImgSavePath
        self.FrameSaveDir.clear()
        self.frameImgSavePath = QtWidgets.QFileDialog.getExistingDirectory(None, "选取文件夹", "C:/")
        frameImgSavePath = self.frameImgSavePath
        self.lineEdit_2.setText(self.frameImgSavePath)
        self.listWidget_2.clear()
        self.label.clear()
        if self.frameImgSavePath=="":
            return
        lst = os.listdir(self.frameImgSavePath)
        for path in lst:
            if(self.frameImgSavePath + "/" + path not in self.FrameSaveDir and path.endswith(".jpg") or path.endswith(".png")):
                self.listWidget_2.addItem(self.frameImgSavePath + "/" + path)
                self.FrameSaveDir.append(self.frameImgSavePath + "/" + path)


    def pushButton_3Fun(self):
        self.aiImgSavePath = QtWidgets.QFileDialog.getExistingDirectory(None, "选取文件夹", "C:/")
        self.lineEdit_3.setText(self.aiImgSavePath)

    def pushButton_8Fun(self):
        self.AIExePath = QtWidgets.QFileDialog.getOpenFileName(None, "选取AI软件", "C:/")[0]
        if self.AIExePath.endswith(".exe"):
            self.lineEdit_4.setText("已选取")
        elif self.AIExePath=="":
            return
        else:
            QtWidgets.QMessageBox.critical(self.listWidget, "错误", "请选择AI软件")
            return
    #下一张
    def pushButton_6Fun(self):
        global Img_paint
        global RawImgSelected
        global frame_paint
        rawImg_list = self.entireRawImg
        if(self.rawImgIndex <= len(rawImg_list) - 2):
            self.rawImgIndex += 1
        else:
            self.rawImgIndex = 0
        Img_paint = rawImg_list[self.rawImgIndex]
        RawImgSelected = self.entireRawImg[self.rawImgIndex]
        self.label_2.setPixmap(QtGui.QPixmap(rawImg_list[self.rawImgIndex]).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
        if (self.frameImgSavePath != None):
            if (self.frameImgSavePath + "/" + (self.rawImgPath + '/' + rawImg_list[self.rawImgIndex]).split("/")[-1][:-4] + ".png" in self.FrameSaveDir):
                frame_name = self.frameImgSavePath + "/" + (self.rawImgPath + '/' + rawImg_list[self.rawImgIndex]).split("/")[-1][:-4] + ".png"
                self.label.setPixmap(QtGui.QPixmap(frame_name).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
                frame_paint = frame_name
            else:
                self.label.clear()
        else:
            self.label.clear()


    # 提取选取图片的框线图
    def extractSelectedImage(self):
        global frame_paint
        if self.frameImgSavePath == None or self.frameImgSavePath == "":
            QtWidgets.QMessageBox.critical(self.listWidget, "错误", "未选定保存框线图的文件夹路径")
            return
        if len(self.rawImgSelected) == 0:
            QtWidgets.QMessageBox.critical(self.listWidget, "错误", "未选定需要提取框线图的图片")
            return
        args = main.parse_args()
        for i in range(len(self.rawImgSelected)):
            self.label_2.setPixmap(
                QtGui.QPixmap(self.rawImgSelected[i]).scaled(self.WIDTH, self.HEIGHT,
                                                     aspectMode=QtCore.Qt.KeepAspectRatio))
            main.main(args, [self.rawImgSelected[i]], self.frameImgSavePath)
            self.label.setPixmap(
                QtGui.QPixmap(self.frameImgSavePath + '/' + self.rawImgSelected[i].split("/")[-1][:-4] + ".png").scaled(
                    self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            frame_paint = self.frameImgSavePath + '/' + self.rawImgSelected[i].split("/")[-1][:-4] + ".png"
            if(self.frameImgSavePath + '/' + self.rawImgSelected[i].split("/")[-1][:-4] + ".png" not in self.FrameSaveDir):
                self.FrameSaveDir.append(self.frameImgSavePath + '/' + self.rawImgSelected[i].split("/")[-1][:-4] + ".png")
                self.listWidget_2.addItem(self.frameImgSavePath + '/' + self.rawImgSelected[i].split("/")[-1][:-4] + ".png")
            QtWidgets.QApplication.processEvents()
        QtWidgets.QMessageBox.information(self.listWidget, "提示", "所选原始图的框线图提取完毕")



    #提取所有图片的框线图
    def extractAllImage(self):
        global frame_paint
        if self.frameImgSavePath==None or self.frameImgSavePath=="":
            QtWidgets.QMessageBox.critical(self.listWidget,"错误", "未选定保存框线图的文件夹路径")
            return
        args = main.parse_args()
        for i in range(len(self.entireRawImg)):
            self.label_2.setPixmap(
                QtGui.QPixmap(self.entireRawImg[i]).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            main.main(args,[self.entireRawImg[i]],self.frameImgSavePath)
            self.label.setPixmap(QtGui.QPixmap(self.frameImgSavePath + '/' + self.entireRawImg[i].split("/")[-1][:-4] + ".png").scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            frame_paint = self.frameImgSavePath + '/' + self.entireRawImg[i].split("/")[-1][:-4] + ".png"
            if(self.frameImgSavePath + '/' + self.entireRawImg[i].split("/")[-1][:-4] + ".png" not in self.FrameSaveDir):
                self.FrameSaveDir.append(self.frameImgSavePath + '/' + self.entireRawImg[i].split("/")[-1][:-4] + ".png")
                self.listWidget_2.addItem(self.frameImgSavePath + '/' + self.entireRawImg[i].split("/")[-1][:-4] + ".png")
            QtWidgets.QApplication.processEvents()
        QtWidgets.QMessageBox.information(self.listWidget, "提示", "所有原始图的框线图提取完毕")



    def ChangeAI(self):
        if self.aiImgSavePath==None or self.aiImgSavePath=="":
            QtWidgets.QMessageBox.critical(self.listWidget, "错误", "未选定保存AI图的文件夹路径")
            return
        if self.frameImgSavePath==None or self.frameImgSavePath=="":
            QtWidgets.QMessageBox.critical(self.listWidget,"错误", "未选定保存框线图的文件夹路径")
            return
        if self.AIExePath ==None or self.AIExePath=="":
            QtWidgets.QMessageBox.critical(self.listWidget, "错误", "未选择AI软件")
            return
        with open("AI.jsx", "r") as f1:
            sentence="".join(f1.readlines()[2:])
            sentence_after="sourceFolder = new Folder(\""+self.frameImgSavePath+"\");\n"+"destFolder = new Folder(\""+self.aiImgSavePath+"\");\n"+sentence
        with open("AI.jsx", "w") as f2:
            f2.write(sentence_after)
        # self.fileT2.setText(path)
        self.command += "\"" + str(self.AIExePath) + "\" "
        self.command += os.getcwd() + "/AI.jsx"
        # cmd = re.sub('\\\\','\\\\', self.command)
        cmd1 = re.sub('\s+', ' ', self.command)
        cmd2 = re.sub("/", "\\\\", cmd1)
        self.command = cmd2
        # print(self.command)
        # print(self.command)
        os.system(self.command)
        self.command = ""
        while(len(os.listdir(self.aiImgSavePath))<len(os.listdir(self.frameImgSavePath))):
            QtWidgets.QApplication.processEvents()
            continue
        # os.system("taskkill " + self.AIExePath)
        lis_AI = os.listdir(self.aiImgSavePath)
        QtWidgets.QMessageBox.information(self.listWidget, "提示", "AI图片已全部提取完成")
        self.listWidget_3.clear()
        for path in lis_AI:
            self.listWidget_3.addItem(self.aiImgSavePath + "/" + path)

    #绘制中位线
    def pushButton_10Fun(self):
        global frame_paint
        global mouseEventType
        global paint_flag
        global RawImgPathExist
        global lis_pos
        lis_pos.clear()
        paint_flag = False
        mouseEventType = 2
        if(len(frame_paint) == 0):
            QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '未选中需要编辑的框线图!')
        else:
            if RawImgPathExist == True:
                Img_raw = self.entireRawImg[self.rawImgIndex]
                self.label_2.setPixmap(
                    QtGui.QPixmap(Img_raw).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            paint_flag = True
            self.label.setPixmap(
                QtGui.QPixmap(frame_paint).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            self.label.setCursor(QtGui.QCursor(QtCore.Qt.CrossCursor))
            self.label.setMouseTracking(False)

    #获取横向和纵向参考线
    def pushButton_11Fun(self):
        global frame_paint
        global mouseEventType
        global paint_flag
        global RawImgPathExist
        global lis_pos
        lis_pos.clear()
        paint_flag = False
        mouseEventType = 3
        if (len(frame_paint) == 0):
            QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '未选中需要编辑的框线图!')
        else:
            if RawImgPathExist==True:
                Img_raw = self.entireRawImg[self.rawImgIndex]
                self.label_2.setPixmap(
                    QtGui.QPixmap(Img_raw).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            paint_flag = True
            self.label.setPixmap(
                QtGui.QPixmap(frame_paint).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            pixmap = QtGui.QPixmap("CursorShape/cursor.png")
            pixmap = pixmap.scaled(601, 601)
            self.label.setCursor(QtGui.QCursor(pixmap, 300, 300))
            self.label.setMouseTracking(False)

    #对称复制
    def pushButton_12Fun(self):
        # 判断是否选中框线图
        global paint_flag
        global RawImgPathExist
        global lis_pos
        lis_pos.clear()
        paint_flag = False
        if (len(frame_paint) == 0):
            QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '未选中需要编辑的框线图!')
            return
        else:
            if RawImgPathExist == True:
                Img_raw = self.entireRawImg[self.rawImgIndex]
                self.label_2.setPixmap(
                    QtGui.QPixmap(Img_raw).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            paint_flag = True
            self.label.setPixmap(
                QtGui.QPixmap(frame_paint).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))

        self.Turn = 0
        # 子窗口
        self.selectWidget = QWidget()
        # 设置窗口标题
        self.selectWidget.setWindowTitle("选择操作类型")
        # 设置窗口大小
        self.selectWidget.resize(400, 300)

        # 左右对称
        self.horizontal = QRadioButton(self.selectWidget)
        self.horizontal.setText('左右对称')
        self.horizontal.move(150, 50)
        self.horizontal.toggled.connect(self.horizontalFun)

        # 上下对称
        self.vertical = QRadioButton(self.selectWidget)
        self.vertical.setText('上下对称')
        self.vertical.move(150, 100)
        self.vertical.toggled.connect(self.verticalFun)

        # 中心旋转复制
        self.revolve = QRadioButton(self.selectWidget)
        self.revolve.setText('中心旋转复制')
        self.revolve.move(150, 150)
        self.revolve.toggled.connect(self.revolveFun)

        # 确认按钮
        self.pushEnter = QPushButton(self.selectWidget)
        self.pushEnter.setText("确认")
        self.pushEnter.move(75, 200)
        self.pushEnter.clicked.connect(self.pushEnterFun)

        # 退出按钮
        self.pushOut = QPushButton(self.selectWidget)
        self.pushOut.setText("取消")
        self.pushOut.move(200, 200)
        self.pushOut.clicked.connect(self.pushOutFun)

        self.selectWidget.show()

#对称复制内部方法
##########################
    # 点击左右对称
    def horizontalFun(self):
        global Turn
        Turn = 1

    # 点击上下对称
    def verticalFun(self):
        global Turn
        Turn = 2

    # 中心旋转复制
    def revolveFun(self):
        global Turn
        Turn = 3

    # 点击确认键
    def pushEnterFun(self):
        global frame_paint
        global Turn
        global mouseEventType
        global paint_flag
        global lis_pos
        self.selectWidget.close()
        if Turn == 0:
            QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '未选中操作!')
        else:
            mouseEventType = 5
            if Turn == 1 or Turn == 2:
                QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '请选择对称轴!')
                pixmap = QtGui.QPixmap("CursorShape/cursor.png")
                if Turn == 1:
                    pixmap = pixmap.scaled(21, 1001)
                elif Turn == 2:
                    pixmap = pixmap.scaled(701, 21)
                self.label.setCursor(QtGui.QCursor(pixmap))
                self.label.setMouseTracking(False)
            elif Turn == 3:
                QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '请选择旋转中心!')
                self.label.setCursor(QtGui.QCursor(QtCore.Qt.CrossCursor))
                self.label.setMouseTracking(False)

    def pushOutFun(self):
        self.selectWidget.close()
##########################################

    #钢笔工具
    def pushButton_13Fun(self):
        global frame_paint
        global mouseEventType
        global paint_flag
        global RawImgPathExist
        global lis_pos
        lis_pos.clear()
        paint_flag = False
        mouseEventType = 4
        if (len(frame_paint) == 0):
            QtWidgets.QMessageBox.information(self.listWidget_2, '提示', '未选中需要编辑的框线图!')
        else:
            if RawImgPathExist==True:
                Img_raw = self.entireRawImg[self.rawImgIndex]
                self.label_2.setPixmap(
                    QtGui.QPixmap(Img_raw).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            paint_flag = True
            self.label.setPixmap(
                QtGui.QPixmap(frame_paint).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            self.label.setCursor(QtCore.Qt.CrossCursor)
            self.label.setMouseTracking(False)

    #钢笔收笔
    def pushButton_15Fun(self):
        global frame_paintCopy
        global frame_paint
        if_ok = QMessageBox.question(None, "钢笔绘制", "是否确定当前绘制内容")
        if if_ok == 65536:
            LABEL.setPixmap(
                QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
            lis_pos.clear()
            frame_paintCopy = None
            return
        else:
            with open(frameImgSavePath + "\\PenRecords.txt", 'a') as file:
                file.write(frame_paint + "钢笔绘制坐标:")
                for i in range(0, len(lis_pos), 2):
                    file.write("(" + str(int(lis_pos[i])) + "," + str(int(lis_pos[i + 1])) + ") ")
                file.write("\n")
            lis_pos.clear()
            frame_paintCopy = None

    #钢笔撤销
    def pushButton_14Fun(self):
        global frame_paintCopy
        global frame_paint
        global lis_pos
        LABEL.setPixmap(
            QtGui.QPixmap(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))
        frame_paintCopy = Ui_Form.cv_imread(self, frame_paint)
        frame_paintCopy = frame_paintCopy.copy()
        if(len(lis_pos) == 4):
            lis_pos.clear()
            return
        elif(len(lis_pos) > 4):
            lis_pos = lis_pos[0 : len(lis_pos) - 2]
            for i in range(0, len(lis_pos) - 3, 2):
                Img_QImage = QtGui.QImage(frame_paint).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio)
                Img_Image = Image.fromarray(frame_paintCopy)
                # 计算label坐标在图片中对应的坐标
                x0 = lis_pos[i + 2] / Img_QImage.width() * Img_Image.width
                y0 = (lis_pos[i + 3] - (
                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                x1 = lis_pos[i] / Img_QImage.width() * Img_Image.width
                y1 = (lis_pos[i + 1] - (
                        H / 2 - Img_QImage.height() / 2)) / Img_QImage.height() * Img_Image.height
                cv2.line(frame_paintCopy, (int(x0), int(y0)), (int(x1), int(y1)), (0, 255, 0), 2)
                RGBImg = cv2.cvtColor(frame_paintCopy, cv2.COLOR_BGR2RGB)
                # 将图片转化成Qt可读格式
                image = QtGui.QImage(RGBImg, RGBImg.shape[1], RGBImg.shape[0],RGBImg.shape[1]*3, QtGui.QImage.Format_RGB888)
                LABEL.setPixmap(
                    QtGui.QPixmap(QtGui.QImage(image)).scaled(W, H, aspectMode=QtCore.Qt.KeepAspectRatio))

    #绘制按钮
    def pushButton_9Fun(self):
        # Feature Point点集列表
        global paint_flag
        paint_flag = False
        global img_paint
        global Img_paintCopy
        global mouseEventType
        global lis_pos
        lis_pos.clear()
        mouseEventType = 1

        self.FeaturePointList = []

        if len(Img_paint) == 0:
            # 打开失败提醒对话框
            QtWidgets.QMessageBox.information(self.listWidget,'提示', '图像打开失败!')
        else:
            self.label_2.setPixmap(
                QtGui.QPixmap(Img_paint).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            paint_flag = True
            Img_paintCopy = self.cv_imread(Img_paint)
            Img_paintCopy = Img_paintCopy.copy()
            size = Img_paintCopy.shape[0:2]  # 原始图像大小
            width, height = size[1], size[0]
            #计算十字中心坐标
            #定义一个fast算法的模型
            fast = cv2.FastFeatureDetector_create(threshold=80, nonmaxSuppression=True)
            # 进行检测
            kps = fast.detect(Img_paintCopy)
            points2f = cv2.KeyPoint_convert(kps)  # 将KeyPoint格式数据中的xy坐标提取出来。
            #分区域
            topLeft = [] #左上角点集
            topRight = [] #右上角点集
            bottomLeft = [] #左下角点集
            bottomRight = [] #右下角点集
            for point in points2f:
                if(point[0] <= width/5 and point[1] < height/2):
                    topLeft.append(point)
                elif(point[0] >= width*4/5 and point[1] < height/2):
                    topRight.append(point)
                elif(point[0] <= width/5 and point[1] > height/2):
                    bottomLeft.append(point)
                elif(point[0] >= width*4/5 and point[1] > height/2):
                    bottomRight.append(point)
            #计算中心点坐标
            try:
                self.topLeftCenter = self.getCenter(topLeft)
                self.topRightCenter = self.getCenter(topRight)
                self.bottomLeftCenter = self.getCenter(bottomLeft)
                self.bottomRightCenter = self.getCenter(bottomRight)
            except IndexError as e:
                QtWidgets.QMessageBox.critical(self.listWidget, "错误", "输入图片中未出现规定十字标志\n请重新选取图片，并重新绘制")
                return

            #获取比例尺长度
            #1113.0
            #506.5
            horizontalScale = (self.topRightCenter[0] - self.topLeftCenter[0] +self.bottomRightCenter[0]-self.bottomLeftCenter[0])/2#水平比例尺长度
            verticalScale = (self.bottomLeftCenter[1] - self.topLeftCenter[1]+self.bottomRightCenter[1]-self.topRightCenter[1])/2 #垂直比例尺长度

            while True:
                real_width, ok1 = QtWidgets.QInputDialog.getDouble(self.listWidget, "真实距离", "\n     请输入水平距离\n", step=0.1)
                real_height, ok2 = QtWidgets.QInputDialog.getDouble(self.listWidget, "真实距离", "\n     请输入垂直距离\n", step=0.1)
                if_ok = QMessageBox.question(None, "真实距离", "水平距离为"+str(real_width)+"\n垂直距离为"+str(real_height)+"\n是否使用当前距离")
                if if_ok==65536:
                    if_re = QMessageBox.question(None, "选择", "是否重新输入")
                    if if_re==65536:
                        break
                    else:
                        continue
                else:
                    break
            global scale
            if real_height==0:
                scale = real_width/horizontalScale
            elif real_width==0:
                scale = real_height/verticalScale
            else:
                scale = (real_width/horizontalScale+real_height/verticalScale)/2
            self.label_2.setPixmap(
                QtGui.QPixmap(Img_paint).scaled(self.WIDTH, self.HEIGHT, aspectMode=QtCore.Qt.KeepAspectRatio))
            self.label_2.setCursor(QtGui.QCursor(QtCore.Qt.CrossCursor))
            self.label_2.setMouseTracking(False)

    #求十字叉中心点坐标
    def getCenter(self, points):
        top = []
        bot = []
        left = []
        right = []
        for i in range(len(points)):
            if (i == 0):
                top = points[i]
                bot = points[i]
                left = points[i]
                right = points[i]
            else:
                if (points[i][0] < left[0]):
                    left = points[i]
                if (points[i][1] < top[1]):
                    top = points[i]
                if (points[i][0] > right[0]):
                    right = points[i]
                if (points[i][1] > bot[1]):
                    bot = points[i]
        return [(right[0] + left[0]) / 2, (bot[1] + top[1]) / 2]

    def getRawImgSelected(self):
        return self.entireRawImg[self.rawImgIndex]
